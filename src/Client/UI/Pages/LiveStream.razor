@page "/livestream"
@using Concerto.Client.Services;
@inject IJSRuntime JS
@inject IStorageService StorageService
@inject IDialogService DialogService
@inject NavigationManager Navigation
@implements IAsyncDisposable

<PageTitle>Live Stream</PageTitle>

<style>
    .container {
        height: 100%;
        width: 100%;
    }

    .buttons {
        grid-area: buttons;
    }

    .buttons > * {
        margin-right: 8px;
    }

    .preview {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: calc(100% - 44px);
    }

    .preview video {
        object-fit: contain;
    }

    .stream-info {
        background: #f5f5f5;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
    }

    .stream-id {
        font-family: monospace;
        font-size: 18px;
        font-weight: bold;
        color: #1976d2;
    }
</style>

@if (LayoutState.IsMobile)
{
    <div class="d-flex align-center justify-center" style="height: 100%">
        <MudText role="alert" Style="text-align: center; margin:auto;" Typo="Typo.h4">Feature unavailable on mobile devices</MudText>
    </div>
}
else
{
    <div class="container pa-1">
        <div class="buttons d-flex py-1">
            <MudText Typo="Typo.caption" Style="align-self: center; margin-right: 8px; color: #666;">
                Live Streaming
            </MudText>

            @if (!IsStreaming)
            {
                <MudButton StartIcon="@Icons.Material.Filled.Videocam" IconColor="Color.Primary" Color="Color.Info" Variant="Variant.Filled" DisableElevation="true" OnClick="StartStream">
                    Start Stream
                </MudButton>
            }
            else
            {
                <MudButton StartIcon="@Icons.Material.Filled.Stop" IconColor="Color.Default" Color="Color.Error" Variant="Variant.Filled" DisableElevation="true" OnClick="StopStream">
                    Stop Stream
                </MudButton>
            }

            @if (!string.IsNullOrEmpty(StreamId))
            {
                <div class="stream-info">
                    <MudText Typo="Typo.subtitle2">Stream ID:</MudText>
                    <div class="stream-id">@StreamId</div>
                    <MudText Typo="Typo.caption">Share this ID with others to let them join your stream</MudText>
                    
                    <div class="mt-3">
                        <MudText Typo="Typo.caption">Or share this link:</MudText>
                        <MudTextField Value="@StreamUrl" 
                                     ReadOnly="true" 
                                     Variant="Variant.Outlined" 
                                     Size="Size.Small"
                                     Class="mt-1"
                                     AppendIcon="@Icons.Material.Filled.ContentCopy"
                                     OnAppendIconClick="CopyStreamUrl" />
                    </div>
                </div>
            }
        </div>

        @if (!IsStreamingPending)
        {
            @if (!IsStreaming)
            {
                <div class="d-flex px-2">
                    <MudIcon Style="align-self: center; margin-right: 2px;" Icon="@Icons.Material.Filled.Mic" />
                    <select style="align-self: stretch; flex-shrink: 1; max-width: 150px;" onclick="@(() => FetchMediaInputs())" @bind="SelectedAudioInputId">
                        @foreach (var input in audioInputs)
                        {
                            <option value="@input.Id">@input.Name</option>
                        }
                        @if (!audioInputs.Any())
                        {
                            <option value="@string.Empty">None</option>
                        }
                    </select>
                </div>

                <div class="d-flex">
                    <MudIcon Style="align-self: center; margin-right: 2px;" Icon="@Icons.Material.Filled.CameraAlt" />
                    <select style="align-self: stretch; flex-shrink: 1; max-width: 150px;" onclick="@(() => FetchMediaInputs())" @bind="SelectedVideoInputId">
                        <option value="@string.Empty">None (Audio only)</option>
                        @foreach (var input in videoInputs)
                        {
                            <option value="@input.Id">@input.Name</option>
                        }
                    </select>
                </div>
            }
        }
        else
        {
            <MudButton StartIcon="@Icons.Material.Filled.CloudUpload" Color="Color.Success" Variant="Variant.Filled" DisableElevation="true" OnClick="SaveStream" Disabled="@string.IsNullOrWhiteSpace(StreamName)">
                Save in workspace
            </MudButton>
            <MudButton StartIcon="@Icons.Material.Filled.Save" Color="Color.Success" Variant="Variant.Filled" DisableElevation="true" OnClick="SaveStreamLocally" Disabled="@string.IsNullOrWhiteSpace(StreamName)">
                Save on computer
            </MudButton>
            <MudButton StartIcon="@Icons.Material.Filled.Delete" Color="Color.Error" Variant="Variant.Filled" DisableElevation="true" OnClick="DiscardStream">
                Discard
            </MudButton>

            <MudInput @bind-Value="StreamName" Placeholder="Stream name" Immediate="true" Label="Stream name" Variant="Variant.Filled" Margin="Margin.None" Class="pa-0" />
        }

        <div id="streamPreview" class="preview">
        </div>
    </div>
}

@code {
    [CascadingParameter] LayoutState LayoutState { get; set; } = LayoutState.Default;

    private (string Name, string Id)[] audioInputs = Array.Empty<(string Name, string Id)>();
    private (string Name, string Id)[] videoInputs = Array.Empty<(string Name, string Id)>();

    private string _selectedAudioInputId = string.Empty;
    private string _selectedVideoInputId = string.Empty;

    private string SelectedAudioInputId
    {
        get { return _selectedAudioInputId; }
        set
        {
            _selectedAudioInputId = value;
            if (_streamingManager is not null)
            {
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await _streamingManager.InvokeVoidAsync("setMicrophone", value);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error setting microphone: {ex.Message}");
                    }
                });
            }
        }
    }

    private string SelectedVideoInputId
    {
        get { return _selectedVideoInputId; }
        set
        {
            _selectedVideoInputId = value;
            if (_streamingManager is not null)
            {
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await _streamingManager.InvokeVoidAsync("setWebcam", value);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error setting webcam: {ex.Message}");
                    }
                });
            }
        }
    }

    bool IsStreaming { get; set; } = false;
    bool IsStreamingPending { get; set; } = false;
    string StreamId { get; set; } = string.Empty;
    string StreamName { get; set; } = string.Empty;
    string StreamUrl => !string.IsNullOrEmpty(StreamId) ? $"{Navigation.BaseUri}joinstream?id={StreamId}" : string.Empty;

    private DotNetObjectReference<LiveStream> _dotNetObjectReference = null!;
    IJSObjectReference? _streamingManager;
    IJSStreamReference? _streamRecording;
    string _streamExtension = string.Empty;

    class MediaDevices
    {
        public string[] Names { get; set; } = null!;
        public string[] Ids { get; set; } = null!;
    }

    protected override void OnInitialized()
    {
        _dotNetObjectReference = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _streamingManager is null)
        {
            _streamingManager = await JS.InvokeAsync<IJSObjectReference>("initializeLiveStreamingManager", "streamPreview", _dotNetObjectReference);
            await FetchMediaInputs();
        }
    }

    private async Task FetchMediaInputs()
    {
        var audioDevices = await GetAudioInputs();
        var videoDevices = await GetVideoInputs();

        audioInputs = audioDevices.Names.Zip(audioDevices.Ids, (name, id) => (name, id)).ToArray();
        videoInputs = videoDevices.Names.Zip(videoDevices.Ids, (name, id) => (name, id)).ToArray();

        if (string.IsNullOrEmpty(SelectedAudioInputId) && audioInputs.Length > 0)
            SelectedAudioInputId = audioInputs[0].Id;

        if (string.IsNullOrEmpty(SelectedVideoInputId) && videoInputs.Length > 0)
            SelectedVideoInputId = videoInputs[0].Id;

        StateHasChanged();
    }

    public async Task StartStream()
    {
        if (_streamingManager is null) return;
        
        try
        {
            StreamId = Guid.NewGuid().ToString("N")[..8].ToUpper(); // Generate 8-character stream ID
            await _streamingManager.InvokeVoidAsync("startStream", StreamId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error starting stream: {ex.Message}");
            // Reset stream ID if start failed
            StreamId = string.Empty;
        }
    }

    public async Task StopStream()
    {
        if (_streamingManager is null) return;
        await _streamingManager.InvokeVoidAsync("stopStream");
        StreamId = string.Empty;
    }

    [JSInvokable]
    public void StreamingStateChanged(bool state)
    {
        IsStreaming = state;
        StateHasChanged();
    }

    [JSInvokable]
    public void StreamingFinished(IJSStreamReference recording, string extension)
    {
        IsStreaming = false;
        IsStreamingPending = true;
        _streamRecording = recording;
        _streamExtension = extension;
        StreamName = $"Stream-{DateTime.Now:yyyy-MM-dd-HH-mm-ss}";
        StateHasChanged();
    }

    public async Task DiscardStream()
    {
        await FinalizeStreaming();
    }

    public async Task SaveStream()
    {
        var destinationFolder = await DialogService.ShowSelectFolderDialog("Select folder for stream recording", "Save here");
        if (destinationFolder is null) return;
        if (_streamRecording is null) return;
        if (string.IsNullOrWhiteSpace(StreamName)) return;

        StorageService.QueueFileToUpload(destinationFolder.Id, _streamRecording, StreamFilename);

        await FinalizeStreaming();
    }

    public async Task SaveStreamLocally()
    {
        if (_streamingManager is null) return;
        await _streamingManager.InvokeVoidAsync("saveStreamLocally", StreamName);
        await FinalizeStreaming();
    }

    public async Task FinalizeStreaming()
    {
        if (_streamingManager is null) return;

        IsStreamingPending = false;
        _streamRecording = null;
        await _streamingManager.InvokeVoidAsync("finalizeStreaming");
        StateHasChanged();
    }

    private string StreamFilename => $"{StreamName}.{_streamExtension}";

    private async Task CopyStreamUrl()
    {
        if (!string.IsNullOrEmpty(StreamUrl))
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", StreamUrl);
            // You could add a toast notification here if you have a notification service
        }
    }

    private async Task<MediaDevices> GetAudioInputs()
    {
        return await JS.InvokeAsync<MediaDevices>("getAudioInputs");
    }

    private async Task<MediaDevices> GetVideoInputs()
    {
        return await JS.InvokeAsync<MediaDevices>("getVideoInputs");
    }

    public async ValueTask DisposeAsync()
    {
        if (IsStreaming)
            await StopStream();

        if (IsStreamingPending)
            await FinalizeStreaming();

        if (_streamingManager is not null)
            await _streamingManager.InvokeVoidAsync("dispose");

        _dotNetObjectReference?.Dispose();
    }
}
