@page "/livestream"
@using Concerto.Client.Services;
@using Concerto.Shared.Extensions;
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication;
@using Microsoft.AspNetCore.Authorization;
@attribute [Authorize(Policy = AuthorizationPolicies.IsAuthenticated.Name)]
@inject IJSRuntime JS
@inject IStorageService StorageService
@inject IDialogService DialogService
@inject NavigationManager Navigation
@inject IAccessTokenProvider _accessTokenProvider
@inject ITranslationsService t
@implements IAsyncDisposable

<PageTitle>@t.T("liveStream", "pageTitle")</PageTitle>

<style>
    .container {
        height: 100%;
        width: 100%;
    }

    .buttons {
        grid-area: buttons;
    }

    .buttons>* {
        margin-right: 8px;
    }

    .preview {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: calc(100% - 44px);
    }

    .preview video {
        object-fit: contain;
    }

    .stream-info {
        background: var(--mud-palette-background-grey);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
    }

    .stream-id {
        font-family: monospace;
        font-size: 18px;
        font-weight: bold;
        color: var(--mud-palette-primary);
    }
</style>

<div class="container pa-1">
    <div class="buttons d-flex py-1">
        <MudText Typo="Typo.caption" Style="align-self: center; margin-right: 8px; color: var(--mud-palette-text-secondary);">
            @t.T("liveStream", "liveStreaming")
        </MudText>

        @if (!IsStreaming)
        {
            <MudButton StartIcon="@Icons.Material.Filled.Videocam" IconColor="Color.Primary" Color="Color.Info"
                Variant="Variant.Filled" DisableElevation="true" OnClick="StartStream">
                @t.T("liveStream", "startStream")
            </MudButton>
        }
        else
        {
            <MudButton StartIcon="@Icons.Material.Filled.Stop" IconColor="Color.Default" Color="Color.Error"
                Variant="Variant.Filled" DisableElevation="true" OnClick="StopStream">
                @t.T("liveStream", "stopStream")
            </MudButton>
        }

        @if (!string.IsNullOrEmpty(StreamId))
        {
            <div class="stream-info">
                <MudText Typo="Typo.subtitle2">@t.T("liveStream", "streamId")</MudText>
                <div class="stream-id">@StreamId</div>
                <MudText Typo="Typo.caption">@t.T("liveStream", "shareIdMessage")</MudText>

                <div class="mt-3">
                    <MudText Typo="Typo.caption">@t.T("liveStream", "orShareLink")</MudText>
                    <MudTextField Value="@StreamUrl" ReadOnly="true" Variant="Variant.Outlined" Size="Size.Small"
                        Class="mt-1" Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.ContentCopy"
                        OnAdornmentClick="CopyStreamUrl" />
                </div>

                @if (ViewerCount > 0)
                {
                    <div class="mt-2">
                        <MudText Typo="Typo.caption">@t.T("liveStream", "viewers", ViewerCount)</MudText>
                    </div>
                }
            </div>
        }
    </div>

    @if (!IsStreamingPending)
    {
        @if (!IsStreaming)
        {
            <div class="d-flex px-2">
                <MudIcon Style="align-self: center; margin-right: 2px;" Icon="@Icons.Material.Filled.Mic" />
                <select style="align-self: stretch; flex-shrink: 1; max-width: 150px;" onclick="@(() => FetchMediaInputs())"
                    @bind="SelectedAudioInputId">
                    @foreach (var input in audioInputs)
                    {
                        <option value="@input.Id">@input.Name</option>
                    }
                    @if (!audioInputs.Any())
                    {
                        <option value="@string.Empty">@t.T("liveStream", "noneOption")</option>
                    }
                </select>
            </div>

            <div class="d-flex">
                <MudIcon Style="align-self: center; margin-right: 2px;" Icon="@Icons.Material.Filled.CameraAlt" />
                <select style="align-self: stretch; flex-shrink: 1; max-width: 150px;" onclick="@(() => FetchMediaInputs())"
                    @bind="SelectedVideoInputId">
                    <option value="@string.Empty">@t.T("liveStream", "noneAudioOnly")</option>
                    @foreach (var input in videoInputs)
                    {
                        <option value="@input.Id">@input.Name</option>
                    }
                </select>
            </div>
        }
    }
    else
    {
        <MudButton StartIcon="@Icons.Material.Filled.CloudUpload" Color="Color.Success" Variant="Variant.Filled"
            DisableElevation="true" OnClick="SaveStream" Disabled="@string.IsNullOrWhiteSpace(StreamName)">
            @t.T("liveStream", "saveInWorkspace")
        </MudButton>
        <MudButton StartIcon="@Icons.Material.Filled.Save" Color="Color.Success" Variant="Variant.Filled"
            DisableElevation="true" OnClick="SaveStreamLocally" Disabled="@string.IsNullOrWhiteSpace(StreamName)">
            @t.T("liveStream", "saveOnComputer")
        </MudButton>
        <MudButton StartIcon="@Icons.Material.Filled.Delete" Color="Color.Error" Variant="Variant.Filled"
            DisableElevation="true" OnClick="DiscardStream">
            @t.T("liveStream", "discard")
        </MudButton>

        <MudInput @bind-Value="StreamName" Placeholder="@t.T("liveStream", "streamNamePlaceholder")" Immediate="true" Label="@t.T("liveStream", "streamName")"
            Variant="Variant.Filled" Margin="Margin.None" Class="pa-0" />
    }

    <div id="streamPreview" class="preview">
    </div>
</div>

@code {
    [CascadingParameter] LayoutState LayoutState { get; set; } = LayoutState.Default;

    private (string Name, string Id)[] audioInputs = Array.Empty<(string Name, string Id)>();
    private (string Name, string Id)[] videoInputs = Array.Empty<(string Name, string Id)>();

    private string _selectedAudioInputId = string.Empty;
    private string _selectedVideoInputId = string.Empty;

    private string SelectedAudioInputId
    {
        get { return _selectedAudioInputId; }
        set
        {
            _selectedAudioInputId = value;
            if (_streamingManager is not null)
            {
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await _streamingManager.InvokeVoidAsync("setMicrophone", value);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error setting microphone: {ex.Message}");
                    }
                });
            }
        }
    }

    private string SelectedVideoInputId
    {
        get { return _selectedVideoInputId; }
        set
        {
            _selectedVideoInputId = value;
            if (_streamingManager is not null)
            {
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await _streamingManager.InvokeVoidAsync("setWebcam", value);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error setting webcam: {ex.Message}");
                    }
                });
            }
        }
    }

    bool IsStreaming { get; set; } = false;
    bool IsStreamingPending { get; set; } = false;
    string StreamId { get; set; } = string.Empty;
    string StreamName { get; set; } = string.Empty;
    string StreamUrl => !string.IsNullOrEmpty(StreamId) ? $"{Navigation.BaseUri}joinstream?id={StreamId}" : string.Empty;
    int ViewerCount { get; set; } = 0;

    private DotNetObjectReference<LiveStream> _dotNetObjectReference = null!;
    IJSObjectReference? _streamingManager;
    IJSStreamReference? _streamRecording;
    string _streamExtension = string.Empty;

    class MediaDevices
    {
        public string[] Names { get; set; } = null!;
        public string[] Ids { get; set; } = null!;
    }

    protected override void OnInitialized()
    {
        _dotNetObjectReference = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (_streamingManager is null)
            {
                _streamingManager = await JS.InvokeAsync<IJSObjectReference>("initializeLiveStreamingManager", "streamPreview",
                _dotNetObjectReference);
                await FetchMediaInputs();
            }
            else
            {
                // Re-append preview canvas when returning to the page
                await _streamingManager.InvokeVoidAsync("appendPreviews", "streamPreview");
            }
        }
    }

    private async Task FetchMediaInputs()
    {
        var audioDevices = await GetAudioInputs();
        var videoDevices = await GetVideoInputs();

        audioInputs = audioDevices.Names.Zip(audioDevices.Ids, (name, id) => (name, id)).ToArray();
        videoInputs = videoDevices.Names.Zip(videoDevices.Ids, (name, id) => (name, id)).ToArray();

        if (string.IsNullOrEmpty(SelectedAudioInputId) && audioInputs.Length > 0)
            SelectedAudioInputId = audioInputs[0].Id;

        if (string.IsNullOrEmpty(SelectedVideoInputId) && videoInputs.Length > 0)
            SelectedVideoInputId = videoInputs[0].Id;

        StateHasChanged();
    }

    public async Task StartStream()
    {
        if (_streamingManager is null) return;

        try
        {
            StreamId = Guid.NewGuid().ToString("N")[..8].ToUpper();
            await _streamingManager.InvokeVoidAsync("startStream", StreamId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error starting stream: {ex.Message}");
            StreamId = string.Empty;
        }
    }

    public async Task StopStream()
    {
        if (_streamingManager is null) return;
        await _streamingManager.InvokeVoidAsync("stopStream");
        StreamId = string.Empty;
        ViewerCount = 0;
    }

    [JSInvokable]
    public async Task<string> GetAccessToken()
    {
        try
        {
            var tokenResult = await _accessTokenProvider.RequestAccessToken();
            return tokenResult.TryGetToken(out var token) ? token.Value : string.Empty;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting access token: {ex.Message}");
            return string.Empty;
        }
    }

    [JSInvokable]
    public void StreamingStateChanged(bool state)
    {
        IsStreaming = state;
        StateHasChanged();
    }

    [JSInvokable]
    public void StreamingFinished(IJSStreamReference recording, string extension)
    {
        IsStreaming = false;
        IsStreamingPending = true;
        _streamRecording = recording;
        _streamExtension = extension;
        StreamName = $"Stream-{DateTime.Now:yyyy-MM-dd-HH-mm-ss}";
        StateHasChanged();
    }

    [JSInvokable]
    public async Task ViewerJoined(string viewerConnectionId)
    {
        ViewerCount++;
        StateHasChanged();

        if (_streamingManager is not null)
        {
            await _streamingManager.InvokeVoidAsync("handleViewerJoined", viewerConnectionId);
        }
    }

    [JSInvokable]
    public void ViewerLeft(string viewerConnectionId)
    {
        ViewerCount = Math.Max(0, ViewerCount - 1);
        StateHasChanged();
    }

    [JSInvokable]
    public async Task ReceiveAnswer(string viewerConnectionId, string answer)
    {
        if (_streamingManager is not null)
        {
            await _streamingManager.InvokeVoidAsync("handleAnswer", viewerConnectionId, answer);
        }
    }

    [JSInvokable]
    public async Task ReceiveIceCandidate(string streamId, string viewerConnectionId, string candidate)
    {
        if (_streamingManager is not null)
        {
            await _streamingManager.InvokeVoidAsync("handleIceCandidate", viewerConnectionId, candidate);
        }
    }

    [JSInvokable]
    public void StreamEnded(string streamId)
    {
        Console.WriteLine($"Stream {streamId} has ended");
        StreamId = string.Empty;
        ViewerCount = 0;
        IsStreaming = false;
        StateHasChanged();
    }

    [JSInvokable]
    public void StreamError(string message)
    {
        Console.WriteLine($"Stream error: {message}");
        StateHasChanged();
    }

    public async Task DiscardStream()
    {
        await FinalizeStreaming();
    }

    public async Task SaveStream()
    {
        var destinationFolder = await DialogService.ShowSelectFolderDialog(t.T("liveStream", "selectFolderDialogTitle"), t.T("liveStream", "selectFolderDialogConfirm"));
        if (destinationFolder is null) return;
        if (_streamRecording is null) return;
        if (string.IsNullOrWhiteSpace(StreamName)) return;

        StorageService.QueueFileToUpload(destinationFolder.Id, _streamRecording, StreamFilename);

        await FinalizeStreaming();
    }

    public async Task SaveStreamLocally()
    {
        if (_streamingManager is null) return;
        await _streamingManager.InvokeVoidAsync("saveStreamLocally", StreamName);
        await FinalizeStreaming();
    }

    public async Task FinalizeStreaming()
    {
        if (_streamingManager is null) return;

        IsStreamingPending = false;
        _streamRecording = null;
        await _streamingManager.InvokeVoidAsync("finalizeStreaming");
        StateHasChanged();
    }

    private string StreamFilename => $"{StreamName}.{_streamExtension}";

    private async Task CopyStreamUrl()
    {
        if (!string.IsNullOrEmpty(StreamUrl))
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", StreamUrl);
        }
    }

    private async Task<MediaDevices> GetAudioInputs()
    {
        return await JS.InvokeAsync<MediaDevices>("getAudioInputs");
    }

    private async Task<MediaDevices> GetVideoInputs()
    {
        return await JS.InvokeAsync<MediaDevices>("getVideoInputs");
    }

    public async ValueTask DisposeAsync()
    {
        if (IsStreaming)
            await StopStream();

        if (IsStreamingPending)
            await FinalizeStreaming();

        if (_streamingManager is not null)
            await _streamingManager.InvokeVoidAsync("dispose");

        _dotNetObjectReference?.Dispose();
    }
}