@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@inject IStorageService StorageService
@inject NavigationManager Navigation
@inject IDialogService DialogService
@inject HubConnection HubConnection
@inject IAccessTokenProvider AccessTokenProvider
@implements IDisposable

<div class="storage-tree">
    @foreach (var node in _rootNodes)
    {
        <TreeNode Node="@node"
                  Depth="0"
                  OnItemClick="@OnItemClick"
                  OnToggleExpand="@OnToggleExpand"
                  LoadChildren="@LoadChildrenAsync" />
    }
</div>

@code {
    private HashSet<TreeItemData> _rootNodes = new();
    private HashSet<long> _expandedNodeIds = new();
    private EventHandler<long>? _uploadHandler;
    private IDisposable? _treeUpdatedSubscription;

    protected override async Task OnInitializedAsync()
    {
        _uploadHandler = (_, _) => _ = RefreshTree();
        StorageService.OnUploadedToFolderEventHandler += _uploadHandler;
        _treeUpdatedSubscription = HubConnection.On<long?>("TreeUpdated", async _ => await RefreshTree());

        if (HubConnection.State == HubConnectionState.Disconnected)
            await HubConnection.StartAsync();

        await RefreshTree();
    }

    private async Task<HashSet<TreeItemData>> LoadChildrenAsync(TreeItemData node)
    {
        var nodes = await LoadNodesAsync(node.Id);
        node.Children = nodes;
        await InvokeAsync(StateHasChanged);
        return nodes;
    }

    private async Task<HashSet<TreeItemData>> LoadNodesAsync(long folderId, bool skipAuthCheck = false)
    {
        if (!skipAuthCheck && !await EnsureAuthenticatedAsync())
            return new HashSet<TreeItemData>();

        var content = await StorageService.GetFolderContentAsync(folderId);
        var nodes = content.SubFolders
            .Select(folder => new TreeItemData { Expandable = folder.HasChildren, Item = folder })
            .Concat(content.Files.Select(file => new TreeItemData { Expandable = false, Item = file }))
            .ToHashSet();

        foreach (var node in nodes.Where(n => n.IsFolder && _expandedNodeIds.Contains(n.Id)))
        {
            node.Expanded = true;
            node.Children = await LoadNodesAsync(node.Id, skipAuthCheck: true);
        }

        return nodes;
    }

    private async Task RefreshTree()
    {
        if (!await EnsureAuthenticatedAsync())
            return;

        _rootNodes = await LoadNodesAsync(-1, skipAuthCheck: true);
        await InvokeAsync(StateHasChanged);
    }

    private async Task<bool> EnsureAuthenticatedAsync()
    {
        var tokenResult = await AccessTokenProvider.RequestAccessToken();
        return tokenResult.TryGetToken(out _);
    }

    private Task OnToggleExpand(TreeItemData node, bool expanded)
    {
        if (expanded)
            _expandedNodeIds.Add(node.Id);
        else
            _expandedNodeIds.Remove(node.Id);

        return Task.CompletedTask;
    }

    private async Task OnItemClick(TreeItemData node)
    {
        if (node.IsFolder)
            Navigation.NavigateTo($"storage/{node.Id}");
        else if (node.Item is FileItem file)
            await DialogService.ShowFilePreviewDialog(file);
    }

    public void Dispose()
    {
        if (_uploadHandler is not null)
            StorageService.OnUploadedToFolderEventHandler -= _uploadHandler;

        _treeUpdatedSubscription?.Dispose();
    }
}
