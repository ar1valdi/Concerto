@using Concerto.Shared.Client.Extensions
@using Concerto.Shared.Client.Services
@using Concerto.Shared.Models.Dto
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using Concerto.Shared.Client.Components.Dialogs
@inherits MudPaper;
@inject HttpClient Http
@inject IDialogService DialogService
@inject IStorageService StorageService
@inject IUserService UserService
@inject ISnackbar Snackbar;
@inject IJSRuntime JS
@inject IAccessTokenProvider AccessTokenProvider

<MudPaper Class="@Class" Style="@Style" Elevation="@Elevation" Outlined="@Outlined">
	@if (FolderContent is not null)
	{
		<MudBreakpointProvider Style="height: inherit; " OnBreakpointChanged="OnBreakPointChanged">
			<MudPaper MinHeight="40px" Outlined="false" Class="pl-4 pa-0 mud-breadcrumbs" Style="background-color: var(--mud-palette-surface);" Elevation="0">
				<MudIconButton DisableElevation="true" Size="Size.Small" Variant="Variant.Filled" Icon="@Icons.Material.Filled.ArrowBack" Disabled="@(BreadCrumbs.Count <= 1)" OnClick="Back"></MudIconButton>
				@foreach (var breadcrumb in BreadCrumbs)
				{
					var isCurrent = FolderContent.Self.Equals(breadcrumb);
						<MudButton Disabled="isCurrent" Style="text-transform: none" Variant="Variant.Text" Color="Color.Default" OnClick="async () => await BreadcrumbBack(breadcrumb)">
							<MudIcon Class="mr-1" Icon="@Icons.Material.Sharp.Folder" />
						@breadcrumb.Name
						</MudButton>
					@if (!isCurrent)
					{
								<MudIcon Icon="@Icons.Material.Sharp.ChevronRight" />
					}
				}
			</MudPaper>

			<MudTable @ref="_table" T="FolderContentItem" Items="FolderContentItems" @bind-SelectedItems="SelectedItems" MultiSelection="@SelectionMode"
			  Loading="_loading" Filter="new Func<FolderContentItem, bool>(FolderContentItemFilter)" SortLabel="Sort By"
				  Class="" Style="height: calc(100% - 40px)" Outlined="false" Height="@($"calc(100% - {TableContentHeightDiff})")" Hover="true" Elevation="0" FixedHeader="true" FixedFooter="true"
			  OnRowClick="OnRowClick" RowStyleFunc="RowStyleFunc" AllowUnsorted="false" Dense="true">
				<ToolBarContent>

					<MudHidden Invert="true" Breakpoint="Breakpoint.SmAndUp">
						<MudIcon Class="mr-2" Icon="@Icons.Material.Sharp.Folder" Size="Size.Large" />
						<MudText Typo="Typo.h5">@FolderContent.Self.Name</MudText>
						<MudSpacer />
					</MudHidden>

					<MudHidden Invert="true" Breakpoint="Breakpoint.Xs">
						<MudIcon Class="mr-2" Icon="@Icons.Material.Sharp.Folder" Size="Size.Medium" />
						<MudText Typo="Typo.body1">@FolderContent.Self.Name</MudText>
						<MudSpacer />
					</MudHidden>


					<div class="ml-2" style=@($"max-width: {(_smallScreen ? "100px;" : "150px")}")>
						<MudTextField @bind-Value="_searchString" Immediate="true" Placeholder="Search" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Small" Margin="Margin.Dense" Class="mt-0 mr-2" />
					</div>

					<MudButtonGroup Class="ml-2" OverrideStyles="false" >


						@if (ChooseFolderMode)
						{
								<MudButton Disabled="@(!FolderContent.Self.CanWrite || ExcludeFromChoose.Contains(FolderContent.Self.Id))" DisableElevation="true" Color="Color.Info" Variant="Variant.Filled" OnClick="() => OnSelected.InvokeAsync(FolderContent.Self)">
								@(ChooseFolderString ?? "Choose")
								</MudButton>
						}

						<MudHidden Breakpoint="Breakpoint.SmAndDown">
							<MudIconButton DisableElevation="true" Icon="@Icons.Material.Filled.Refresh" Color="Color.Default" Variant="Variant.Filled" OnClick="Refresh" />
							@if (!ChooseFolderMode)
							{
								<MudIconButton DisableElevation="true" Icon="@Icons.Material.Filled.UploadFile" Color="Color.Default" Variant="Variant.Filled" OnClick="async () => await UploadFiles()" Disabled="@(!FolderContent.Self.CanWrite)" />
								<MudIconButton DisableElevation="true" Icon="@Icons.Material.Filled.CreateNewFolder" Color="Color.Default" Variant="Variant.Filled" OnClick="async () => await ShowCreateFolderDialog()" Disabled="@(!FolderContent.Self.CanWrite)" />
								<MudIconButton DisableElevation="true" Size="Size.Small" Color="Color.Default" Variant="Variant.Filled" Icon="@(SelectionMode ? Icons.Material.Filled.Deselect : Icons.Material.Filled.SelectAll)"
									   OnClick="() => SelectionMode = !SelectionMode" />
							}
						</MudHidden>

						<MudMenu Dense="true">
							<ActivatorContent>
								<MudIconButton DisableElevation="true" Icon="@Icons.Material.Filled.MoreVert" Color="Color.Default" Variant="Variant.Filled" />
							</ActivatorContent>
							<ChildContent>

								<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.Refresh"
									  OnClick="Refresh" OnTouch="Refresh">
									Refresh view
								</MudMenuItemW>

								@if (!ChooseFolderMode)
								{
										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.UploadFile"
									  OnClick="async () => await UploadFiles()" OnTouch="async () => await UploadFiles()"
									  Disabled="@(!FolderContent.Self.CanWrite)">
											Upload files
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.CreateNewFolder"
									  OnClick="async () => await ShowCreateFolderDialog()" OnTouch="async () => await ShowCreateFolderDialog()"
									  Disabled="@(!FolderContent.Self.CanWrite)">
											Create folder
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.Settings"
									  OnClick="async () => await ShowUpdateFolderDialog(FolderContent.Self)" OnTouch="async () => await ShowUpdateFolderDialog(FolderContent.Self)"
									  Disabled="@(!FolderContent.Self.CanEdit)">
											Settings
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@(SelectionMode ? Icons.Material.Filled.Deselect : Icons.Material.Filled.SelectAll)"
														OnClick="() => SelectionMode = !SelectionMode" OnTouch="() => SelectionMode = !SelectionMode">
										@(!SelectionMode ? "Select" : "Cancel selection")
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.DriveFileMove"
									  OnClick="async () => await MoveSelected()" OnTouch="async () => await MoveSelected()"
									  Disabled="@(!CanMoveSelected)">
											Move selected to
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.ContentCopy"
									  OnClick="async () => await CopySelected()" OnTouch="async () => await CopySelected()"
									  Disabled="@(!CanCopySelected)">
											Copy selected to
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Error" Icon="@Icons.Material.Filled.DeleteSweep"
									  OnClick="async () => await DeleteSelected()" OnTouch="async () => await DeleteSelected()"
									  Disabled="@(!CanCopySelected)">
											Delete selected
										</MudMenuItemW>
								}
							</ChildContent>
						</MudMenu>
					</MudButtonGroup>

				</ToolBarContent>

				<ColGroup>
					@if (SelectionMode)
					{
							<col style="width: 10px" />
					}
					<col />
					<col />
					<col />
					<col />
				</ColGroup>

				<HeaderContent>
					<MudTh>


						<MudTableSortLabel @ref="_nameLabel" InitialDirection="SortDirection.Ascending"
								   SortBy="new Func<FolderContentItem, object>(x => FolderPrecedence(_nameLabel.SortDirection, x) + x.Name)">
							Name
						</MudTableSortLabel>


					</MudTh>
					<MudTh>
						<MudTableSortLabel @ref="_formatLabel"
								   SortBy="new Func<FolderContentItem, object>(x => FolderPrecedence(_formatLabel.SortDirection, x) + ((x as FileItem)?.Extension ?? DirFormat + x.Name ))">
							Format
						</MudTableSortLabel>
					</MudTh>
					<MudTh>
						<MudTableSortLabel @ref="_typeLabel"
								   SortBy="new Func<FolderContentItem, object>(x => FolderPrecedence(_typeLabel.SortDirection, x) + x.ToDisplayString() + x.Name)">
							Type
						</MudTableSortLabel>
					</MudTh>
					<MudTh></MudTh>
				</HeaderContent>

				<RowTemplate>
					@if (context is FolderItem folder)
					{
							<MudTd DataLabel="Name" Style="">
								<MudStack Row="true">
									<MudIcon Size="Size.Medium" Icon="@Icons.Material.Filled.Folder" />
									<MudText Typo="Typo.body2">@context.Name</MudText>
								</MudStack>
							</MudTd>
							<MudTd DataLabel="Format">@DirFormat</MudTd>
							<MudTd DataLabel="Type">
								<MudStack Row="true">
									<MudIcon Size="Size.Medium" Icon="@folder.Type.ToIcon()" />
									<MudText Typo="Typo.body2">@folder.Type.ToDisplayString()</MudText>
								</MudStack>
							</MudTd>
							<MudTd Style="text-align: right">
								<MudMenu Dense="true">
									<ActivatorContent>
									@if (_smallScreen)
									{
												<MudButton DisableElevation="true" StartIcon="@Icons.Material.Filled.MoreVert" Color="Color.Default" Variant="Variant.Filled">Actions</MudButton>
									}
									else
									{
												<MudIconButton DisableElevation="true" Icon="@Icons.Material.Filled.MoreVert" Color="Color.Default" Variant="Variant.Filled" />
									}
									</ActivatorContent>
									<ChildContent>
									@if (SelectionMode)
									{
										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.DriveFileMove"
										  OnClick="async () => await MoveSelected()" OnTouch="async () => await MoveSelected()"
										  Disabled="@(!CanMoveSelected)">
											Move selected to
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.ContentCopy"
										  OnClick="async () => await CopySelected()" OnTouch="async () => await CopySelected()"
										  Disabled="@(!CanCopySelected)">
											Copy selected to
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Error" Icon="@Icons.Material.Filled.DeleteSweep"
										  OnClick="async () => await DeleteSelected()" OnTouch="async () => await DeleteSelected()"
										  Disabled="@(!CanCopySelected)">
											Delete selected
										</MudMenuItemW>
									}
									else
									{
										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.FolderOpen"
										  OnClick="() => OpenFolder(folder)" OnTouch="() => OpenFolder(folder)">
											Open
										</MudMenuItemW>
										<MudMenuItemW hidden="@ChooseFolderMode" IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.Settings"
										  OnClick="() => ShowUpdateFolderDialog(folder)" OnTouch="() => ShowUpdateFolderDialog(folder)"
										  Disabled=@(!folder.CanEdit)>
											Settings
										</MudMenuItemW>
										<MudMenuItemW hidden="@ChooseFolderMode" IconSize="Size.Small" IconColor="Color.Error" Icon="@Icons.Material.Filled.Delete"
										  OnClick="async () => await DeleteFolder(folder)" OnTouch="async () => await DeleteFolder(folder)"
										  Disabled=@(!folder.CanDelete)>
											Delete
										</MudMenuItemW>
									}

									</ChildContent>
								</MudMenu>
							</MudTd>
					}
					else if (context is FileItem file)
					{
							<MudTd DataLabel="Name" Style="">
								<MudStack Row="true">
									<MudIcon Size="Size.Medium" Icon="@Icons.Material.Filled.InsertDriveFile" />
									<MudText Typo="Typo.body2">@context.Name</MudText>
								</MudStack>
							</MudTd>
							<MudTd DataLabel="Format">
								<MudStack Row="true">
									<MudText Typo="Typo.body2">@file.Extension</MudText>
								</MudStack>
							</MudTd>
							<MudTd DataLabel="Type">
								<MudStack Row="true">
									<MudStack Row="true">
										<MudIcon Size="Size.Medium" Icon="@file.ToIcon()" />
										<MudText Typo="Typo.body2">@file.ToDisplayString()</MudText>
									</MudStack>
								</MudStack>
							</MudTd>
							<MudTd Style="text-align: right">
								<MudMenu Dense="true" hidden="@ChooseFolderMode">
									<ActivatorContent>
									@if (_smallScreen)
									{
												<MudButton DisableElevation="true" StartIcon="@Icons.Material.Filled.MoreVert" Color="Color.Default" Variant="Variant.Filled">Actions</MudButton>
									}
									else
									{
												<MudIconButton DisableElevation="true" Icon="@Icons.Material.Filled.MoreVert" Color="Color.Default" Variant="Variant.Filled" />
									}
									</ActivatorContent>
									<ChildContent>


									@if (SelectionMode)
									{
										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.DriveFileMove"
										  OnClick="async () => await MoveSelected()" OnTouch="async () => await MoveSelected()"
										  Disabled="@(!CanMoveSelected)">
											Move selected to
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.ContentCopy"
										  OnClick="async () => await CopySelected()" OnTouch="async () => await CopySelected()"
										  Disabled="@(!CanCopySelected)">
											Copy selected to
										</MudMenuItemW>

										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Error" Icon="@Icons.Material.Filled.DeleteSweep"
										  OnClick="async () => await DeleteSelected()" OnTouch="async () => await DeleteSelected()"
										  Disabled="@(!CanCopySelected)">
											Delete selected
										</MudMenuItemW>
									}
									else
									{
										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.Download"
										  OnClick="() => DownloadFile(file)" OnTouch="() => DownloadFile(file)">
											Download
										</MudMenuItemW>
										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Default" Icon="@Icons.Material.Filled.Edit"
										  OnClick="() => ShowUpdateFileDialog(file)" OnTouch="() => ShowUpdateFileDialog(file)"
										  Disabled=@(!file.CanEdit)>
											Edit
										</MudMenuItemW>
										<MudMenuItemW IconSize="Size.Small" IconColor="Color.Error" Icon="@Icons.Material.Filled.Delete"
										  OnClick="() => DeleteFile(file)" OnTouch="() => DeleteFile(file)"
										  Disabled=@(!file.CanDelete)>
											Delete
										</MudMenuItemW>
									}
									</ChildContent>
								</MudMenu>
							</MudTd>
					}
				</RowTemplate>
			</MudTable>
		</MudBreakpointProvider>
	}
</MudPaper>



@code {

	[Parameter]
	public bool ChooseFolderMode { get; set; } = false;

	[Parameter]
	public string? ChooseFolderString { get; set; }

	[Parameter]
	public HashSet<long> ExcludeFromChoose { get; set; } = new();

	[Parameter]
	public EventCallback<FolderItem> OnSelected { get; set; }



	[Parameter]
	public long InitialFolderId { get; set; }
	
	private string _height = string.Empty;
	
	private bool _smallScreen = false;
	private void OnBreakPointChanged(Breakpoint breakpoint) => _smallScreen = breakpoint <= Breakpoint.Xs;
	private string TableContentHeightDiff => _smallScreen ? "128px" : "64px";


	private MudTable<FolderContentItem>? _table;

	private FolderContent? FolderContent { get; set; }
	private List<FolderContentItem>? FolderContentItems { get; set; }


	private HashSet<FolderContentItem> SelectedItems { get; set; } = new();
	private bool CanMoveSelected => SelectionMode && SelectedItems.Any() && SelectedItems.All(i => i.CanDelete);
	private bool CanCopySelected => SelectionMode && SelectedItems.Any();
	private bool CanDeleteSelected => SelectionMode && SelectedItems.Any() && SelectedItems.All(i => i.CanDelete);
	private bool _selectionMode = false;

	private bool SelectionMode
	{
		get => _selectionMode;
		set
		{
			_selectionMode = value;
			StateHasChanged();
			SelectedItems.Clear();
		}
	}

	MudTableSortLabel<FolderContentItem>? _nameLabel;
	MudTableSortLabel<FolderContentItem>? _formatLabel;
	MudTableSortLabel<FolderContentItem>? _typeLabel;


	private string DirFormat => "folder";
	private string FolderPrecedence(SortDirection? dir, FolderContentItem item)
	{
		return item switch
		{
			FolderItem folder when dir is SortDirection.Ascending or SortDirection.None  => "A",
			FolderItem folder when dir is SortDirection.Descending => "Z",

			FileItem file when dir is SortDirection.Ascending or SortDirection.None => "Z",
			FileItem file when dir is SortDirection.Descending => "A",
			_ => ""
			};
	}

	private List<FolderItem> BreadCrumbs { get; } = new();

	private class FolderBreadcrumbItem : BreadcrumbItem
	{
		public FolderItem FolderItem { get; set; }

		public FolderBreadcrumbItem(FolderItem folderItem, bool disabled = false) : base(folderItem.Name, string.Empty, disabled)
		{
			FolderItem = folderItem;
		}
	}

	private bool _loading = true;
	private string? _searchString;
	private long? CurrentFolderId => FolderContent?.Self.Id;

	protected override async Task OnParametersSetAsync()
	{
		var currentInitialFolderId = BreadCrumbs.FirstOrDefault()?.Id;
		if (currentInitialFolderId != InitialFolderId)
		{
			SelectionMode = false;
			BreadCrumbs.Clear();
			await LoadFolderContent(InitialFolderId);
			BreadCrumbs.Add(FolderContent!.Self);
		}
	}

	private async Task Refresh()
	{
		if (CurrentFolderId != null)
		{
			SelectionMode = false;
			await LoadFolderContent(CurrentFolderId.Value);
		}
	}

	private async Task LoadFolderContent(long folderId)
	{
		_loading = true;
		FolderContent = await StorageService.GetFolderContentAsync(folderId);
		var files = FolderContent.Files.Cast<FolderContentItem>();
		var subFolders = FolderContent.SubFolders.Cast<FolderContentItem>();
		FolderContentItems = files.Concat(subFolders).ToList();
		_loading = false;
	}

	private bool FolderContentItemFilter(FolderContentItem item)
	{
		if (string.IsNullOrWhiteSpace(_searchString))
			return true;
		if (item.Name.Contains(_searchString, StringComparison.OrdinalIgnoreCase))
			return true;
		return false;
	}

	public async Task UploadFiles()
	{
		var parameters = new DialogParameters { ["FolderId"] = FolderContent!.Self.Id };
		var result = await DialogService.Show<UploadFilesDialog>("Upload files to folder", parameters).Result;
		await Refresh();
	}

	public async Task DeleteFolder(FolderItem folder)
	{
		await StorageService.DeleteFolderAsync(folder.Id);
		await Refresh();
	}

	public async Task DeleteSelected()
	{
		var request = new DeleteFolderItemsRequest
		{
			FileIds = SelectedItems!.Where(x => x is FileItem).Select(x => x.Id),
			FolderIds = SelectedItems!.Where(x => x is FolderItem).Select(x => x.Id)
		};
		try
		{
			var itemsNames = string.Join(",\n\n", SelectedItems.Select(x => x.Name));
			if (!await DialogService.ShowDeleteManyConfirmationDialog("Delete folder items", "folder items", itemsNames)) return;
			await StorageService.DeleteFolderItemsAsync(request);
			Snackbar.Add("Items deleted", Severity.Success);
			await Refresh();
		}
		catch
		{
			Snackbar.Add("Failed to delete items", Severity.Error);
			await Refresh();
		}
	}

	public async Task MoveSelected()
	{
		var moved = await DialogService.ShowMoveFolderItemsDialog(SelectedItems, FolderContent!.Self.Id, FolderContent!.CourseId);
		if (moved) await Refresh();
	}

	public async Task CopySelected()
	{
		var copied = await DialogService.ShowCopyFolderItemsDialog(SelectedItems, FolderContent!.Self.Id, FolderContent!.CourseId);
		if(copied) await Refresh();
	}


	public async Task DeleteFile(FileItem file)
	{
		try
		{
			if (!await DialogService.ShowDeleteConfirmationDialog("Delete file", "file", file.Name)) return;
			await StorageService.DeleteFileAsync(file.Id);
			Snackbar.Add("File deleted", Severity.Success);
		}
		catch
		{
			Snackbar.Add("Failed to delete file", Severity.Success);
		}
		await Refresh();
	}

	public async Task ShowCreateFolderDialog()
	{
		var parameters = new DialogParameters
		{
			["ParentFolderId"] = FolderContent!.Self.Id,
			["ParentFolderPermission"] = FolderContent.CoursePermission.Type
		};
		var name = "Create folder";
		var result = await DialogService.Show<CreateFolderDialog>(name, parameters).Result;
		if ((bool)(result.Data ?? false))
		{
			await Refresh();
		}
	}

	public async Task ShowUpdateFolderDialog(FolderItem editedFolder)
	{
		var parameters = new DialogParameters { ["EditedFolderId"] = editedFolder.Id };
		var name = "Edit folder";
		var result = await DialogService.Show<UpdateFolderDialog>(name, parameters).Result;
		if ((bool)(result.Data ?? false))
		{
			await Refresh();
		}
	}

	public async Task ShowUpdateFileDialog(FileItem file)
	{
		var parameters = new DialogParameters { ["EditedFileId"] = file.Id };
		var name = "Edit file";
		var result = await DialogService.Show<UpdateFileDialog>(name, parameters).Result;
		if (result.Cancelled) return;
		await Refresh();
	}

	public async Task DownloadFile(FileItem file)
	{
		var accessTokenResult = await AccessTokenProvider.RequestAccessToken();
		accessTokenResult.TryGetToken(out var accessToken);

		await JS.InvokeVoidAsync("downloadFile", file.Name, $"{Http.BaseAddress}Storage/DownloadFile?fileId={file.Id}&access_token={accessToken.Value}");
	}

	public async Task OpenFolder(FolderItem folder)
	{
		await LoadFolderContent(folder.Id);
		BreadCrumbs.Add(FolderContent!.Self);
		SelectedItems.Clear();
	}

	private async Task OnRowClick(TableRowClickEventArgs<FolderContentItem> tableClick)
	{
		if (SelectionMode) return;
		var item = tableClick.Item;
		if (item is FolderItem)
		{
			await OpenFolder((FolderItem)item);
		}
	}

	public string RowStyleFunc(FolderContentItem item, int rowNumber)
	{
		if (item is FolderItem) return "cursor: pointer;";
		return string.Empty;
	}

	public async Task BreadcrumbBack(FolderItem item)
	{
		var itemIndex = BreadCrumbs.IndexOf(item);
		var itemsLeft = BreadCrumbs.Count - itemIndex;
		BreadCrumbs.RemoveRange(itemIndex, itemsLeft);
		await OpenFolder(item);
	}

	public async Task Back()
	{
		if (BreadCrumbs.Count > 1)
		{
			await BreadcrumbBack(BreadCrumbs[^2]);
		}
	}

}